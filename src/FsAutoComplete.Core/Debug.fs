// --------------------------------------------------------------------------------------
// (c) Robin Neatherway
// --------------------------------------------------------------------------------------
namespace FsAutoComplete

/// loggers that are shared between components
[<RequireQualifiedAccess>]
module Loggers =
  open FsAutoComplete.Logging

  let analyzers = LogProvider.getLoggerByName "Analyzers"


[<RequireQualifiedAccess>]
module Debug =
  open System
  open System.Collections.Concurrent
  open FsAutoComplete.Logging

  let toggleVerboseLogging (verbose: bool) = () // todo: set logging latch

  let waitForDebugger () =
    while not (Diagnostics.Debugger.IsAttached) do
      System.Threading.Thread.Sleep(100)

  type LogCompilerFunctionId =
    | Service_ParseAndCheckFileInProject = 1
    | Service_CheckOneFile = 2
    | Service_IncrementalBuildersCache_BuildingNewCache = 3
    | Service_IncrementalBuildersCache_GettingCache = 4
    | CompileOps_TypeCheckOneInputAndFinishEventually = 5
    | IncrementalBuild_CreateItemKeyStoreAndSemanticClassification = 6
    | IncrementalBuild_TypeCheck = 7

  let logFunctionName (payload: obj) =
    Log.addContextDestructured "function" (payload :?> int |> enum<LogCompilerFunctionId>)


  module FSharpCompilerEventLogger =
    open System.Diagnostics.Tracing

    let logger = LogProvider.getLoggerByName "Compiler"

    /// listener for the the events generated by the `FSharp.Compiler.FSharpCompilerEventSource`
    type Listener() =
      inherit EventListener()

      let mutable source = null

      let inflightEvents = ConcurrentDictionary<_, DateTimeOffset>()

      let eventLevelToLogLevel (e: EventLevel) =
        match e with
        | EventLevel.Critical -> logger.fatal
        | EventLevel.Error -> logger.error
        | EventLevel.Informational -> logger.info
        | EventLevel.LogAlways -> logger.fatal
        | EventLevel.Verbose -> logger.debug
        | EventLevel.Warning -> logger.warn
        | _ -> logger.info

      override __.OnEventSourceCreated newSource =
        if newSource.Name = "FSharpCompiler" then
          ``base``.EnableEvents(newSource, EventLevel.LogAlways, EventKeywords.All)
          source <- newSource

      override __.OnEventWritten eventArgs =

        let message =
          match eventArgs.EventId with
          | 0 -> Log.setMessage (string eventArgs.Payload.[0])
          | 1 ->
            Log.setMessage "In {function}"
            >> logFunctionName eventArgs.Payload.[0]
          | 2 ->
            Log.setMessage "{function}: {message}"
            >> logFunctionName eventArgs.Payload.[1]
            >> Log.addContextDestructured "message" eventArgs.Payload.[0]
          | 3 ->
            inflightEvents.TryAdd(eventArgs.Task, DateTimeOffset.UtcNow)
            |> ignore

            Log.setMessage "Started {function}"
            >> logFunctionName eventArgs.Payload.[0]
          | 4 ->
            match inflightEvents.TryRemove(eventArgs.Task) with
            | true, startTime ->
              let delta = DateTimeOffset.UtcNow - startTime

              Log.setMessage "Finished {function} in {seconds}"
              >> logFunctionName eventArgs.Payload.[0]
              >> Log.addContextDestructured "seconds" delta.TotalSeconds
            | false, _ ->
              Log.setMessage "Finished {function}"
              >> logFunctionName eventArgs.Payload.[0]
          | 5 ->
            inflightEvents.TryAdd(eventArgs.Task, DateTimeOffset.UtcNow)
            |> ignore

            Log.setMessage "Started {function}: {message}"
            >> logFunctionName eventArgs.Payload.[1]
            >> Log.addContextDestructured "message" eventArgs.Payload.[0]
          | 6 ->
            match inflightEvents.TryRemove(eventArgs.Task) with
            | true, startTime ->
              let delta = DateTimeOffset.UtcNow - startTime

              Log.setMessage "Finished {function}: {message} ({seconds} seconds)"
              >> logFunctionName eventArgs.Payload.[1]
              >> Log.addContextDestructured "seconds" delta.TotalSeconds
              >> Log.addContextDestructured "message" (eventArgs.Payload.[0])
            | false, _ ->
              Log.setMessage "Finished {function}: {message}"
              >> logFunctionName eventArgs.Payload.[1]
              >> Log.addContextDestructured "message" eventArgs.Payload.[0]
          | other ->
            Log.setMessage "Unknown event {name}({id}) with payload {payload}"
            >> Log.addContext "id" other
            >> Log.addContextDestructured "name" eventArgs.EventName
            >> Log.addContextDestructured "payload" (eventArgs.Payload |> Seq.toList)

        (eventLevelToLogLevel eventArgs.Level) message

      interface System.IDisposable with
        member __.Dispose() =
          if isNull source then
            ()
          else
            ``base``.DisableEvents(source)
