// --------------------------------------------------------------------------------------
// (c) Robin Neatherway
// --------------------------------------------------------------------------------------
namespace FsAutoComplete

/// loggers that are shared between components
[<RequireQualifiedAccess>]
module Loggers =
  open FsAutoComplete.Logging

  let analyzers = LogProvider.getLoggerByName "Analyzers"


[<RequireQualifiedAccess>]
module Debug =
  open System
  open System.Diagnostics
  open System.Collections.Concurrent
  open FsAutoComplete.Logging

  let measureLogger = LogProvider.getLoggerByName "Measurer"

  let measure name f =
    let sw = Stopwatch.StartNew()
    let r = f ()
    let ellapsed = sw.ElapsedMilliseconds

    measureLogger.info (
      Log.setMessage ("{name} took {ellapsed} ms")
      >> Log.addContextDestructured "name" name
      >> Log.addContextDestructured "ellapsed" ellapsed
    )

    r

  let measureAsync name f =
    async {
      let sw = Stopwatch.StartNew()
      let! r = f
      let ellapsed = sw.ElapsedMilliseconds

      measureLogger.info (
        Log.setMessage ("{name} took {ellapsed} ms")
        >> Log.addContextDestructured "name" name
        >> Log.addContextDestructured "ellapsed" ellapsed
      )

      return r
    }

  let toggleVerboseLogging (verbose: bool) = () // todo: set logging latch

  let waitForDebugger () =
    while not (Diagnostics.Debugger.IsAttached) do
      System.Threading.Thread.Sleep(100)

  let logger = LogProvider.getLoggerByName "Debugging"

  let waitForDebuggerAttached (programName) =
#if DEBUG
    if not (System.Diagnostics.Debugger.IsAttached) then
      logger.info (
        Log.setMessage (
          sprintf
            "Please attach a debugger for %s, PID: %d"
            programName
            (System.Diagnostics.Process.GetCurrentProcess().Id)
        )
      )

    while not (System.Diagnostics.Debugger.IsAttached) do
      System.Threading.Thread.Sleep(100)
#else
    ()
#endif
  let waitForDebuggerAttachedAndBreak (programName) =
#if DEBUG
    waitForDebuggerAttached programName
    System.Diagnostics.Debugger.Break()
#else
    ()
#endif


  type LogCompilerFunctionId =
    | Service_ParseAndCheckFileInProject = 1
    | Service_CheckOneFile = 2
    | Service_IncrementalBuildersCache_BuildingNewCache = 3
    | Service_IncrementalBuildersCache_GettingCache = 4
    | CompileOps_TypeCheckOneInputAndFinishEventually = 5
    | IncrementalBuild_CreateItemKeyStoreAndSemanticClassification = 6
    | IncrementalBuild_TypeCheck = 7

  let logFunctionName (payload: obj) =
    Log.addContextDestructured "function" (payload :?> int |> enum<LogCompilerFunctionId>)


  module FSharpCompilerEventLogger =
    open System.Diagnostics.Tracing

    let logger = LogProvider.getLoggerByName "Compiler"

    /// listener for the the events generated by the `FSharp.Compiler.FSharpCompilerEventSource`
    type Listener() =
      inherit EventListener()

      let mutable source = null

      let inflightEvents = ConcurrentDictionary<_, DateTimeOffset>()

      let eventLevelToLogLevel (e: EventLevel) =
        match e with
        | EventLevel.Critical -> logger.fatal
        | EventLevel.Error -> logger.error
        | EventLevel.Informational -> logger.info
        | EventLevel.LogAlways -> logger.fatal
        | EventLevel.Verbose -> logger.debug
        | EventLevel.Warning -> logger.warn
        | _ -> logger.info

      override __.OnEventSourceCreated newSource =
        if newSource.Name = "FSharpCompiler" then
          ``base``.EnableEvents(newSource, EventLevel.LogAlways, EventKeywords.All)
          source <- newSource

      override __.OnEventWritten eventArgs =

        let message =
          match eventArgs.EventId with
          | 0 -> Log.setMessage (string eventArgs.Payload.[0]) |> Some
          | 1 -> Log.setMessage "In {function}" >> logFunctionName eventArgs.Payload.[0] |> Some
          | 2 ->
            Log.setMessage "{function}: {message}"
            >> logFunctionName eventArgs.Payload.[1]
            >> Log.addContextDestructured "message" eventArgs.Payload.[0]
            |> Some
          | 3 ->
            inflightEvents.TryAdd(eventArgs.Task, DateTimeOffset.UtcNow) |> ignore

            Log.setMessage "Started {function}"
            >> logFunctionName eventArgs.Payload.[0]
            |> Some
          | 4 ->
            match inflightEvents.TryRemove(eventArgs.Task) with
            | true, startTime ->
              let delta = DateTimeOffset.UtcNow - startTime

              Log.setMessage "Finished {function} in {seconds}"
              >> logFunctionName eventArgs.Payload.[0]
              >> Log.addContextDestructured "seconds" delta.TotalSeconds
            | false, _ -> Log.setMessage "Finished {function}" >> logFunctionName eventArgs.Payload.[0]
            |> Some
          | 5 ->
            inflightEvents.TryAdd(eventArgs.Task, DateTimeOffset.UtcNow) |> ignore

            Log.setMessage "Started {function}: {message}"
            >> logFunctionName eventArgs.Payload.[1]
            >> Log.addContextDestructured "message" eventArgs.Payload.[0]
            |> Some
          | 6 ->
            match inflightEvents.TryRemove(eventArgs.Task) with
            | true, startTime ->
              let delta = DateTimeOffset.UtcNow - startTime

              Log.setMessage "Finished {function}: {message} ({seconds} seconds)"
              >> logFunctionName eventArgs.Payload.[1]
              >> Log.addContextDestructured "seconds" delta.TotalSeconds
              >> Log.addContextDestructured "message" (eventArgs.Payload.[0])
              |> Some
            | false, _ ->
              Log.setMessage "Finished {function}: {message}"
              >> logFunctionName eventArgs.Payload.[1]
              >> Log.addContextDestructured "message" eventArgs.Payload.[0]
              |> Some
          | other -> None
        // Log.setMessage "Unknown event {name}({id}) with payload {payload}"
        // >> Log.addContext "id" other
        // >> Log.addContextDestructured "name" eventArgs.EventName
        // >> Log.addContextDestructured "payload" (eventArgs.Payload |> Seq.toList)
        message |> Option.iter (eventLevelToLogLevel eventArgs.Level)

      interface System.IDisposable with
        member __.Dispose() =
          if isNull source then () else ``base``.DisableEvents(source)
